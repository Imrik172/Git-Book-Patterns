---
description: Curiously recurring template pattern
---

# CRTP

Идиома "Статический полиморфизм" (CRTP) разделяет функциональность, зависящую от типа и связывает функциональность, независимую от типа, с базовым классом, используя шаблон с "саморекурсией".

{% hint style="info" %}
Шаблоны позволяют создавать обобщенные алгоритмы и контейнеры, которые могут работать с различными типами данных. Компилятор при использовании шаблона генерирует конкретный код для каждого типа данных, что позволяет избежать дублирования кода.
{% endhint %}

## Решаемые задачи

* достижение статического полиморфизма
* избежание дублирования кода
* получение возможности повторного использования кода

## Недостатки&#x20;

* необходимость явного указания типа данных при использовании шаблонов, что приводит к усложнению кода и затруднении чтения и поддержки
* шаблоны могут занимать большой объем памяти, если используются для хранения больших объемов данных
* не подходит для задач, которые требуют динамического выбора данных во время выполнения программы (в этом случае используются виртуальные функции и динамический полиморфизм)

## Пример реализации идиомы CRTP&#x20;

{% code lineNumbers="true" fullWidth="true" %}
```cpp
template <class derived>
struct compare {};

struct value : compare<value> 
{
    int m_x;
    value(int x) : m_x(x) {}
    bool operator<(const value &rhs) const 
    { 
        return m_x < rhs.m_x; 
    }
};

template <class derived>
bool operator > (const compare<derived> &lhs, const compare<derived> &rhs) 
{
    // static_assert(std::is_base_of_v<compare<derived>, derived>); // Безопасность времени компиляции
    return (static_cast<const derived&>(rhs) < static_cast<const derived&>(lhs));
}

int main() 
{
    value v1{5}, v2{10};
    cout << boolalpha << "v1 > v2: " << (v1 > v2) << '\n';
    return 0;
}
```
{% endcode %}
