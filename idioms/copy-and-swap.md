---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Copy and swap

## Назначение

Идиома Copy and swap является одним из подходов к реализации операции присваивания для объектов класса. Она предлагает эффективный способ обеспечить безопасную и эффективную реализацию этой операции. Используется для реализации оператора присваивания, конструктора копирования, обмена значениями.

## Решаемые задачи

* Безопасное присваивание объектов

При изменении состояния одного или нескольких объектов на любом этапе модификации может возникнуть исключительная ситуация, приводящая к неправильному освобождению ресурсов, если произошла ошибка после выделения памяти для нового объекта. Идиома Copy and swap обеспечитвает безопасность операции присваивания. Она позволяет избежать проблем с самоприсваиванием[^1] и  гарантировать освобождение ресурсов.

## Общая реализация на языке C++

{% hint style="info" %}
Реализация идиомы заключается в создании функции swap(), которая:

1. Создает копию объектов;
2. Изменяет копию. Оригинальные объекты остаются нетронутыми;
3. Если все изменения прошли успешно – происходит замена оригинального объекта измененной копией. Если же при изменении копии на каком-то этапе появилась ошибка, то оригинальный объект не меняется.

В данном примере для обмена значениями реализована функция swap(). Благодаря этому удается избежать утечки памяти в случае генерации исключения.
{% endhint %}

{% code fullWidth="true" %}
```cpp
template<typename T>
class Array {
    public:
        Array(unsigned size) : data{ new T[size] }, size{ size } { }  
        ~Array() { delete [] data; } 

        Array(const Array& array) : Array{ array.size } {
            for (unsigned i {}; i < size; ++i)
                data[i] = array.data[i];
        }
        
        Array <T>& operator=(const Array& other) {
            Array <T> copy{ other };    
            swap(copy);                
            return *this;
        }

        T & operator[](unsigned index) 
        { 
            return data[index]; 
        }
        
        void swap(Array & other) noexcept  {
            std::swap(data, other.data);    // меняются два указателя
            std::swap(size, other.size);    // меняются размеры
        }
        
        unsigned getSize() const 
        { 
            return size;
        }
        
private:
    T * data;         
    unsigned size; 
};
```
{% endcode %}

[^1]: Самоприсваивание - это ситуация, когда объект присваивает самому себе. Это может произойти, когда переменной присваивается значение, которое уже содержится в этой переменной.
