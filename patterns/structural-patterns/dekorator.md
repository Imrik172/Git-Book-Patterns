---
description: Decorator
layout:
  title:
    visible: true
  description:
    visible: true
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Декоратор

## Назначение

* Паттерн Decorator динамически добавляет новые обязанности объекту. Декораторы являются гибкой альтернативой порождению подклассов для расширения функциональности.
* Рекурсивно декорирует основной объект.
* Паттерн Decorator использует схему "обертываем подарок, кладем его в коробку, обертываем коробку".

## Решаемые задачи

* динамическое, прозрачное для клиентов добавление обязанностей объектам
* реализация обязанностей, которые могут быть сняты с объекта
* применяется,  когда расширение путем порождения подклассов по каким-то причинам неудобно или невозможно

#### Пояснение к последнему пункту:

Иногда приходится реализовывать много независимых расширений, так что порождение подклассов для поддержки всех возможных комбинаций приведет к комбинаторному росту их числа. В других случаях определение класса может быть скрыто или почему-либо еще недоступно, так что породить от него подкласс нельзя.

## Общая реализация на языке С++

{% code lineNumbers="true" fullWidth="true" %}
```cpp
# include <iostream>
# include <memory>

using namespace std;

class Component
{
public:
    virtual ~Component() = default;
    virtual void operation() = 0;
};

class ConComponent : public Component
{
public:
    void operation() override { cout << "ConComponent; "; }
};

class Decorator : public Component
{
protected:
    shared_ptr<Component> component;
public:
    Decorator(shared_ptr<Component> comp) : component(comp) {}
};

class ConDecorator : public Decorator
{
public:
    using Decorator::Decorator;
    void operation() override;
};

# pragma region Method
void ConDecorator::operation()
{
    if (component)
    {
    component->operation();
    cout << "ConDecorator; ";
    }

}

# pragma endregion

int main()
{
    shared_ptr<Component> component = make_shared<ConComponent>();
    shared_ptr<Component> decorator1 = make_shared<ConDecorator>(component);

    decorator1->operation();
    cout << endl;

    shared_ptr<Component> decorator2 = make_shared<ConDecorator>(decorator1);

    decorator2->operation();
    cout << endl;
}
```
{% endcode %}

## Связь с другими паттернами

* [Компоновщик](composite.md): декоратор можно рассматривать как вырожденный случай компоновщика с единственным компонентом. Однако Decorator добавляет новые обязанности и не предназначен для агрегирования объектов.
* [Стратегия](../behavioral-patterns/strategy.md): декоратор хорошо совмещается вместе с паттерном стратегия. Декоратор позволяет изменить внешний облик объекта, стратегия – его внутреннее содержание. Это два взаимодополняющих способа изменения объекта.
* [Адаптер](adapter.md): если декоратор изменяет только обязанности объекта, но не его интерфейс, то адаптер придает объекту совершенно новый интерфейс.

## Достоинства

* Гибкость: возможность добавлять желаемую реализацию к любой сущности в момент выполнения программы. Появлется возможность "декорировать" декораторы.
* Отсутсвие разрастания иерархии.
* Позволяет избежать перегруженных функциями классов на верхних уровнях иерархии.
* Возможность обращаться с декорированным объектом так же как и с исходной сущностью.
* Отсутствия дублирования кода, данный код просто уходит в конкретный декоратор.

## Недостатки

* Снижение производительности программы.

Не используя декораторы можно напрямую пользоваться методом класса. Декоратор же может долго полиморфно совершать цепочку вызовов, что сказывается на времени выполнения программы.

* Вся ответственность за декорирование "ложится на плечи" программиста

Нет сущности, которая бы полностью отвечала за последовательность декорирования: за порядок вызова и оборачивания декораторов

* В случае если в цепочке вызовов декоратора появляется необходимость изменить какую-либо обертку или удалить ее, то приходится заново оборачивать исходный объект.
* Необходимость в создании сущности, отвечающей за декорирование.

